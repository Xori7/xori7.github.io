<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-16">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet" href="../include/prism.css">
    <title>xori</title>
</head>
<body>

<div class="markdown-content" id="markdown-output"></div>

<script src="../include/marked.js"></script>
<script src="../include/prism.js"></script>
<script>
    marked.setOptions({
        highlight: function(code, lang) {
            if (lang && Prism.languages[lang]) {
                return Prism.highlight(code, Prism.languages[lang], lang);
            }
            return code;
        }
    });

    const output = document.getElementById('markdown-output');
    output.innerHTML = marked.parse(`
< [home](../index.html) > 

## 001 | 08/28/2025 | Bitflags are awesome 

---

> This is not a very meaningful/ambitious post imo. Just wanted to try out my new css and syntax highlighting :P

So I'm writing a communication system for my strategy game. And I have to decide how to structure
data, so that it fits my needs.

Thirst let me define the problem.

I have different order types, and corresponding parameters, such as:

- move order:
    - region/front-line
    - attitude
- ask for help:
    - region/front-line
    - unit types
- share information:
    - share visible enemies
    - share visible allies
    - share visible infrastructure
    - share supplies info
    - share health info

On way (very c#-like way) would be to make an interface and implement each order as separate struct

\`\`\`cs
interface IOrder {
}

struct MoveOrder : IOrder {
    public MapRegion Region;
    public AttitudeType Attitude;
}

struct HelpOrder : IOrder {
    public MapRegion Region;
    public (UnitType, int amount)[] RequestUnits;
}

struct ShareInfoOrder : IOrder {
    public bool ShareVisibleEnemies;
    public bool ShareVisibleAllies;
    public bool ShareVisibleInfrastructure;
    public bool ShareSuppliesInfo;
    public bool ShareHealthInfo;
}

//etc...
\`\`\`

Another way would be to make a fat-struct with type enum

\`\`\`cs
enum OrderType {
    Move,
    Help,
    ShareInfo
}

struct Order {
    public OrderType Type;
    public AttitudeType Attitude;
    public MapRegion Region;
    public (UnitType, int amount)[] Units;
    public bool ShareVisibleEnemies;
    public bool ShareVisibleAllies;
    public bool ShareVisibleInfrastructure;
    public bool ShareSuppliesInfo;
    public bool ShareHealthInfo;
    //etc...
}
\`\`\`

**In my case** I prefere the second approach (fat-struct), because it gives me data locality (same sized non-managed types), faster runtime,
simpler code and one thing that is very useful.

That thing is the ability to flag different OrderTypes based on which fields they use.
To achieve that, I can simply reserve specific bits in OrderType for flags, that indicate whether specific field is being used by OrderType.

\`\`\`cs
enum OrderField {
    Attitude = 1 << 31,
    Region = 1 << 30,
    Units = 1 << 29,
    Sharing = 1 << 28,
}
\`\`\`

And then use that in OrderType:

\`\`\`cs
enum OrderType {
    Move = 1 | Attitude | Region,
    Help = 2 | Region | Units,
    ShareInfo = 3 | Sharing
}
\`\`\`

I will probably extend this approach to parametrize OrderType, so that each field can have a note about what is the purpose of using it
(mainly for the player to know).

    `);
</script>

</body>
</html>
